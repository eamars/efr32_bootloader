<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>RAIL: Memory_Management</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RAIL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="http://www.silabs.com"><span>silabs.com</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___memory___management.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Memory_Management<div class="ingroups"><a class="el" href="group___r_a_i_l___a_p_i.html">RAIL_API</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Application callbacks to provide memory for RAIL actions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2028542bcfd123ee6da1c6f51a6769bc"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory___management.html#ga2028542bcfd123ee6da1c6f51a6769bc">RAILCb_AllocateMemory</a> (uint32_t size)</td></tr>
<tr class="memdesc:ga2028542bcfd123ee6da1c6f51a6769bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function used by RAIL to request memory.  <a href="#ga2028542bcfd123ee6da1c6f51a6769bc">More...</a><br/></td></tr>
<tr class="separator:ga2028542bcfd123ee6da1c6f51a6769bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04f525285e2c6fc2e7266d6c3a14f417"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory___management.html#ga04f525285e2c6fc2e7266d6c3a14f417">RAILCb_FreeMemory</a> (void *handle)</td></tr>
<tr class="memdesc:ga04f525285e2c6fc2e7266d6c3a14f417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function used by RAIL to free memory.  <a href="#ga04f525285e2c6fc2e7266d6c3a14f417">More...</a><br/></td></tr>
<tr class="separator:ga04f525285e2c6fc2e7266d6c3a14f417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88e5f0da9a6542ea07595f8f11ba776c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory___management.html#ga88e5f0da9a6542ea07595f8f11ba776c">RAILCb_BeginWriteMemory</a> (void *handle, uint32_t offset, uint32_t *available)</td></tr>
<tr class="memdesc:ga88e5f0da9a6542ea07595f8f11ba776c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called to begin copying received data into the current memory handle.  <a href="#ga88e5f0da9a6542ea07595f8f11ba776c">More...</a><br/></td></tr>
<tr class="separator:ga88e5f0da9a6542ea07595f8f11ba776c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga846a2317ace667dbb2b70acb473d816e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory___management.html#ga846a2317ace667dbb2b70acb473d816e">RAILCb_EndWriteMemory</a> (void *handle, uint32_t offset, uint32_t size)</td></tr>
<tr class="memdesc:ga846a2317ace667dbb2b70acb473d816e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called to complete the write memory transaction.  <a href="#ga846a2317ace667dbb2b70acb473d816e">More...</a><br/></td></tr>
<tr class="separator:ga846a2317ace667dbb2b70acb473d816e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Application callbacks to provide memory for RAIL actions. </p>
<p>The RAIL library does not want to dictate how upper layers handle memory allocation for packet receive data. At the same time we need to put the packets somewhere to give them to the upper layers. To abstract this we require the user application to implement the <a class="el" href="group___memory___management.html#ga2028542bcfd123ee6da1c6f51a6769bc" title="Callback function used by RAIL to request memory. ">RAILCb_AllocateMemory()</a>, <a class="el" href="group___memory___management.html#ga04f525285e2c6fc2e7266d6c3a14f417" title="Callback function used by RAIL to free memory. ">RAILCb_FreeMemory()</a>, <a class="el" href="group___memory___management.html#ga88e5f0da9a6542ea07595f8f11ba776c" title="Called to begin copying received data into the current memory handle. ">RAILCb_BeginWriteMemory()</a>, and <a class="el" href="group___memory___management.html#ga846a2317ace667dbb2b70acb473d816e" title="Called to complete the write memory transaction. ">RAILCb_EndWriteMemory()</a> callbacks. These callbacks will be called from interrupt context to interact with whatever memory allocation system your application uses.</p>
<p>Memory will be allocated for receiving a packet whenever we think we need it. This depends on the chip you're using and possibly the size of your maximum packet. We will never ask for more memory than <code>MAX_PACKET_SIZE + sizeof(\ref <a class="el" href="struct_r_a_i_l___rx_packet_info__t.html" title="Receive packet information structure. ">RAIL_RxPacketInfo_t</a>)</code> where MAX_PACKET_SIZE is the maximum packet your PHY is configured to receive over the air. Once you give us the handle to this memory it must stay valid until we tell you we are done with it using the <a class="el" href="group___memory___management.html#ga04f525285e2c6fc2e7266d6c3a14f417" title="Callback function used by RAIL to free memory. ">RAILCb_FreeMemory()</a> callback. Generally this will happen immediately after we call the <a class="el" href="group___receive.html#gac7097f4d704df33f93bd95b5af6318d5" title="Receive packet callback. ">RAILCb_RxPacketReceived()</a> function with that handle. RAIL has no concept of an invalid handle so we will attempt to use whatever you pass to us. This means that you will still receive all callbacks for invalid handles even if we are forced to drop receive packet bytes because they don't fit anywhere.</p>
<p>If the handle is invalid you must make sure your callbacks do not crash and that <a class="el" href="group___memory___management.html#ga88e5f0da9a6542ea07595f8f11ba776c" title="Called to begin copying received data into the current memory handle. ">RAILCb_BeginWriteMemory()</a> returns a NULL pointer or 0 bytes available so that we do not try to write to this memory. In this case, the packet data will be dropped.</p>
<p>To actually write data to the handle you provide us we need to convert it into an actual memory pointer. We will do this each time we need to access the memory by calling <a class="el" href="group___memory___management.html#ga88e5f0da9a6542ea07595f8f11ba776c" title="Called to begin copying received data into the current memory handle. ">RAILCb_BeginWriteMemory()</a>. This function must return a pointer to the requested offset in the memory buffer allocated. If you are using non-contiguous memory buffers you can also return the number of bytes available before we need to re-request a pointer with a new offset. Once the access is complete we will call <a class="el" href="group___memory___management.html#ga846a2317ace667dbb2b70acb473d816e" title="Called to complete the write memory transaction. ">RAILCb_EndWriteMemory()</a> with information about exactly how many bytes were written at the specified offset. After this call we will always call <a class="el" href="group___memory___management.html#ga88e5f0da9a6542ea07595f8f11ba776c" title="Called to begin copying received data into the current memory handle. ">RAILCb_BeginWriteMemory()</a> again before trying to write any more data. In the event that you receive an invalid handle these APIs must return NULL or set available bytes to 0 so that we do not attempt to write packet data to the buffer.</p>
<p>This system is fairly flexible and can tie into many higher level memory allocation APIs. A simple example using one static buffer for memory allocation is shown below. You will probably want a more advanced system that can handle receiving multiple packets simultaneously.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> uint8_t buffer[MAX_PACKET_SIZE + <span class="keyword">sizeof</span>(<a class="code" href="struct_r_a_i_l___rx_packet_info__t.html">RAIL_RxPacketInfo_t</a>)];</div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">bool</span> isAllocated = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> *<a class="code" href="group___memory___management.html#ga2028542bcfd123ee6da1c6f51a6769bc">RAILCb_AllocateMemory</a>(uint32_t size)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> i = 0;</div>
<div class="line">  <span class="keywordtype">void</span> *ptr = NULL;</div>
<div class="line">  CORE_DECLARE_IRQ_STATE;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// We can&#39;t support sizes greater than the maximum buffer size</span></div>
<div class="line">  <span class="keywordflow">if</span>(size &gt; (MAX_PACKET_SIZE + <span class="keyword">sizeof</span>(<a class="code" href="struct_r_a_i_l___rx_packet_info__t.html">RAIL_RxPacketInfo_t</a>))) {</div>
<div class="line">    <span class="keywordflow">return</span> NULL;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Disable interrupts and attempt to grab the buffer</span></div>
<div class="line">  CORE_ENTER_CRITICAL();</div>
<div class="line">  <span class="keywordflow">if</span> (isAllocated) {</div>
<div class="line">    ptr = NULL;</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    isAllocated = <span class="keyword">true</span>;</div>
<div class="line">    ptr = buffer;</div>
<div class="line">  }</div>
<div class="line">  CORE_EXIT_CRITICAL();</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> ptr;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="group___memory___management.html#ga04f525285e2c6fc2e7266d6c3a14f417">RAILCb_FreeMemory</a>(<span class="keywordtype">void</span> *ptr)</div>
<div class="line">{</div>
<div class="line">  CORE_CRITICAL_SECTION(</div>
<div class="line">    isAllocated = <span class="keyword">false</span>;</div>
<div class="line">  );</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> *<a class="code" href="group___memory___management.html#ga88e5f0da9a6542ea07595f8f11ba776c">RAILCb_BeginWriteMemory</a>(<span class="keywordtype">void</span> *handle,</div>
<div class="line">                              uint32_t offset,</div>
<div class="line">                              uint32_t *available)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> ((uint8_t*)handle) + offset;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="group___memory___management.html#ga846a2317ace667dbb2b70acb473d816e">RAILCb_EndWriteMemory</a>(<span class="keywordtype">void</span> *handle, uint32_t offset, uint32_t size)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Do nothing</span></div>
<div class="line">}</div>
</div><!-- fragment --> <h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga2028542bcfd123ee6da1c6f51a6769bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* RAILCb_AllocateMemory </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function used by RAIL to request memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The amount of memory in bytes that we need for this packet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle to memory in your storage system.</dd></dl>
<p>This is used to allocate memory for receive packets and must be implemented by the application. </p>

</div>
</div>
<a class="anchor" id="ga88e5f0da9a6542ea07595f8f11ba776c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* RAILCb_BeginWriteMemory </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>available</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called to begin copying received data into the current memory handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>A handle to the current memory block for packet data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The offset in bytes from the start of the handle that we need a pointer for. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">available</td><td>The number of bytes available to be written to this return pointer. If this is zero the receive will terminate. This parameter will default to all spaces allocated to handle contiguous allocators. If your allocator is different you <em>must</em> set this appropriately. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the address to write data for this handle.</dd></dl>
<p>This function is called before every memory write to a handle so that we can get the actual address this handle references in the system. When we're done writing there will be a corresponding call to <a class="el" href="group___memory___management.html#ga846a2317ace667dbb2b70acb473d816e" title="Called to complete the write memory transaction. ">RAILCb_EndWriteMemory()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>You must have at least <code>sizeof(RAIL_RxPacketInfo_t)</code> contiguous bytes at offset 0 or the appended info will not be written. </dd></dl>

</div>
</div>
<a class="anchor" id="ga846a2317ace667dbb2b70acb473d816e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RAILCb_EndWriteMemory </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called to complete the write memory transaction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle to the current memory block we're modifying. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset in bytes from the start of the handle that this data was written to. </td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes that were written.</td></tr>
  </table>
  </dd>
</dl>
<p>This callback indicates the completeion of a write memory transaction. It can be used to store information about how many bytes were written or anything else needed. Once this is called the pointer returned by <a class="el" href="group___memory___management.html#ga88e5f0da9a6542ea07595f8f11ba776c" title="Called to begin copying received data into the current memory handle. ">RAILCb_BeginWriteMemory()</a> will no longer be assumed to be valid and we will call that function again for any future writes. </p>

</div>
</div>
<a class="anchor" id="ga04f525285e2c6fc2e7266d6c3a14f417"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RAILCb_FreeMemory </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function used by RAIL to free memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>A handle to a memory block allocated with the <a class="el" href="group___memory___management.html#ga2028542bcfd123ee6da1c6f51a6769bc" title="Callback function used by RAIL to request memory. ">RAILCb_AllocateMemory()</a> API above.</td></tr>
  </table>
  </dd>
</dl>
<p>This is used to free memory that was allocated with the <a class="el" href="group___memory___management.html#ga2028542bcfd123ee6da1c6f51a6769bc" title="Callback function used by RAIL to request memory. ">RAILCb_AllocateMemory()</a> function when RAIL is done using it. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Apr 7 2017 16:17:14 for RAIL by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
