<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>RAIL: EFR32</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RAIL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="http://www.silabs.com"><span>silabs.com</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('efr32_main.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">EFR32 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>While RAIL attempts to be chip agnostic there are certain hardware differences that can't be overlooked. Where possible, missing features will be simulated in software, but performance characteristics may vary. This section will cover what differs for the EFR32 series of chips as well as any hardware specific configurations or calibrations.</p>
<h2>Packet Buffer Restrictions</h2>
<p>Currently the RAIL library for the EFR32 allocates internal buffers to store the receive and transmit data contiguously. These buffers are set to 512 bytes each at build time and cannot be removed. This choice limits the maximum size of receive and transmit packets in packet mode and determines the size of the FIFO in FIFO mode. Since each receive packet has 8 bytes of overhead this means that you can only receive up to one 504 byte packet. Transmit does not have this restriction and you may send a full 512 byte packet.</p>
<p>In the future these buffers will likely be made user configurable to accommodate different applications. Note, however, that the EFR32 will always require a power of 2 sized buffer due to the underlying hardware.</p>
<h2>Data Reception Sources</h2>
<p>When receiving data, you can configure hardware to provide data from three different hardware sources.</p>
<p>First, you can configure the hardware to provide a packet of information. This configuration utilizes the built-in demodulator and frame controller. Use <a class="el" href="group___data___management.html#gga16584c741da74d9fa7bfb6c6b74012b9a51031cf6cfe1090806bd80081a48febd">RAIL_RxDataSource_t::RX_PACKET_DATA</a> to enable this receive source.</p>
<p>Second, you can configure the hardware to provide data directly from the demodulator. In this mode, the hardware demodulator is used, but the user is responsible for implementing frame controller functionality. (i.e. Preamble detection, sync word detection, CRC validation, etc. must be performed in software by the application.) All data returned is represented as 8-bit 2's-compliment values. Use <a class="el" href="group___data___management.html#gga16584c741da74d9fa7bfb6c6b74012b9a3680d24c321ca9595f80f4062284de82">RAIL_RxDataSource_t::RX_DEMOD_DATA</a> to enable this receive source.</p>
<p>Third, you can configure the hardware to provide data directly from the I and Q ADCs. In this mode, the user is responsible for implementing demodulator and frame controller functionality. The receive signal hardware has a 19-bit dynamic range, and the user can select whether to return the upper 16 bits of the 19-bit value (<a class="el" href="group___data___management.html#gga16584c741da74d9fa7bfb6c6b74012b9adfa3e1b96a7fed050c2e5a94c84e5e7a">RAIL_RxDataSource_t::RX_IQDATA_FILTMSB</a>) or the lower 16 bits (<a class="el" href="group___data___management.html#gga16584c741da74d9fa7bfb6c6b74012b9ad7221f15ed90ababb5aea07e8492a1b1">RAIL_RxDataSource_t::RX_IQDATA_FILTLSB</a>). All data returned is represented as 16-bit 2s-compliment values. The I and Q values are put into the buffer in an alternating fashion where the first 16-bit value is the first I ADC value, and the second 16-bit value is the first Q ADC value, etc.</p>
<h2>Hardware Initialization</h2>
<p>The EFR32 comes with versions of EMLIB and EMDRV to create a basic HAL layer. A lot of this initialization code is completely up to you, but there are a couple of requirements when you're building a RAIL app. Specifically, the radio will only work if you are running off a high precision crystal oscillator. Since some APIs will assume this is running you should make sure to initialize and switch to the crystal before calling any radio APIs.</p>
<p>For the WSTK you can use the crystal configuration stored in the bspconfig.h header file for your specific kit. Example code for this is shown below. If you have a custom hardware layout you may want to create your own HFXOInit structure to account for things like your specific CTUNE value.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;bsp.h&quot;</span> <span class="comment">// Contains WSTK versions of the HFXO init structure</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> efrStartup(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  CMU_HFXOInit_TypeDef hfxoInit = CMU_HFXOINIT_WSTK_DEFAULT;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Initialize the HFXO using the settings from the WSTK bspconfig.h</span></div>
<div class="line">  <span class="comment">// Note: This configures things like the capacitive tuning CTUNE variable</span></div>
<div class="line">  <span class="comment">//   which can vary based on your hardware design.</span></div>
<div class="line">  CMU_HFXOInit(&amp;hfxoInit);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Switch HFCLK to HFXO and disable HFRCO</span></div>
<div class="line">  CMU_ClockSelectSet(cmuClock_HF, cmuSelect_HFXO);</div>
<div class="line">  CMU_OscillatorEnable(cmuOsc_HFRCO, <span class="keyword">false</span>, <span class="keyword">false</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><h3>Interrupt Vectors</h3>
<p>The RAIL library for EFR32 implements all of the interrupt vectors for radio peripherals. This is required for the RAIL library to function correctly. RAIL does not, however, set the priorities of these interrupt vectors. That must be handled by your application using the CMSIS NVIC_SetPriority() API or direct manipulation of the NVIC. Below is the full list of interrupts used by the radio. We recommend running them all at the same priority which is what our RAIL applications do by default. You are free to choose what that priority is based on the requirements of your application (e.g. putting them below FreeRTOS atomic for access to OS functions in RAIL callbacks). Keep in mind that putting the radio interrupts at too low a priority can cause missed packets and other radio performance issues. A restriction on EFR32xG12/13 is not to disable radio interrupts for longer than quarter of the RAIL timebase, which is 2^32/4 microseconds or 18 minutes. Please see <a class="el" href="group___e_f_r32x_g1x___interrupts.html">EFR32xG1x_Interrupts</a> or follow the links below for more information.</p>
<div class="fragment"><div class="line"><a class="code" href="group___e_f_r32x_g1x___interrupts.html#ga5136e4598377244337749247a93f0432">FRC_PRI_IRQHandler</a></div>
<div class="line"><a class="code" href="group___e_f_r32x_g1x___interrupts.html#ga0c7a131a40ec0f4f4aedbdad5f15b399">FRC_IRQHandler</a></div>
<div class="line"><a class="code" href="group___e_f_r32x_g1x___interrupts.html#ga0c462dd15369865c11875a6146538578">MODEM_IRQHandler</a></div>
<div class="line"><a class="code" href="group___e_f_r32x_g1x___interrupts.html#gadc2b9acaacd718dcd2e78deacd2b015b">RAC_SEQ_IRQHandler</a></div>
<div class="line"><a class="code" href="group___e_f_r32x_g1x___interrupts.html#ga20868c2069184ad702beabab4606af73">RAC_RSM_IRQHandler</a></div>
<div class="line"><a class="code" href="group___e_f_r32x_g1x___interrupts.html#gaf0715f354743cd91d25299840842a730">BUFC_IRQHandler</a></div>
<div class="line"><a class="code" href="group___e_f_r32x_g1x___interrupts.html#ga1381fd3f099f38e273bb091a176fe073">AGC_IRQHandler</a></div>
<div class="line"><a class="code" href="group___e_f_r32x_g1x___interrupts.html#gaae7189e0f1296a5c53a26a45a2d762ad">PROTIMER_IRQHandler</a></div>
<div class="line"><a class="code" href="group___e_f_r32x_g1x___interrupts.html#ga7e71cb986f574513f202d02f97a3eb63">SYNTH_IRQHandler</a></div>
<div class="line"><a class="code" href="group___e_f_r32x_g1x___interrupts.html#ga289a52d34c2bbc45e59e4b4c3dc3b958">RFSENSE_IRQHandler</a></div>
</div><!-- fragment --><h2>Radio Specific Initialization</h2>
<p>Currently there are two initialization functions for the radio that depend on your board configuration and must be manually called at startup. You <b>MUST</b> initialize the power amplifier (PA) in order to transmit. You <b>MUST</b> also initialize the PA before initializing RAIL for the library to properly account for the PA settings during timing calculations. You may initialize the packet trace interface (PTI) if you want to use this for debugging.</p>
<h3>Power Amplifier (PA) Initialization</h3>
<p>There are several different PAs available for the EFR32 family of chips. The specific set of PAs you have available and the supported power levels are determined by what part number you're using. To fully understand your part and what options you have please consult the data sheet for your part.</p>
<p>Once you have chosen the PA configuration that you need it's important that you initialize the PA before doing any radio operations, but after the HFXO has been enabled and switched to. The structures and APIs for doing this can be found in the <a class="el" href="pa_8h.html" title="RADIO PA API. ">pa.h</a> file. An example of initializing the high power 2.4GHz PA is shown below.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="pa_8h.html">pa.h</a>&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> initPa(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="struct_r_a_d_i_o___p_a_init__t.html">RADIO_PAInit_t</a> paInit = {</div>
<div class="line">    <a class="code" href="group___e_f_r32x_g1x___p_a.html#ggab28ad7adbcb6eb4882e3edb59e7cfabca30a40b0a2fcd66c4667bce5f54b52435">PA_SEL_2P4_HP</a>,    <span class="comment">// Mode: PA_SEL_SUBGIG, PA_SEL_2P4_LP, PA_SEL_2P4_HP</span></div>
<div class="line">    <a class="code" href="group___e_f_r32x_g1x___p_a.html#ggaa97c6da583caff03a4029d12793d1f6aaab457f73f7a465d6ecba91eb95f02ebb">PA_VOLTMODE_DCDC</a>, <span class="comment">// VPA mode: PA_VOLTMODE_VBAT, PA_VOLTMODE_DCDC</span></div>
<div class="line">    100,              <span class="comment">// Desired output power in dBm * 10</span></div>
<div class="line">    0,                <span class="comment">// Output power offset in dBm * 10</span></div>
<div class="line">    10,               <span class="comment">// Desired ramp time in us</span></div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Initialize the PA (must be done only after the HFXO is enabled)</span></div>
<div class="line">  <span class="keywordflow">if</span> (!<a class="code" href="group___e_f_r32x_g1x___p_a.html#ga309eb1612cc931425a9b7b91341124bb">RADIO_PA_Init</a>(&amp;paInit)) {</div>
<div class="line">    <span class="comment">// Error: The PA could not be initialized due to an improper configuration.</span></div>
<div class="line">    <span class="comment">// Please ensure your configuration is valid for the selected part.</span></div>
<div class="line">    <span class="keywordflow">while</span>(1);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h3>Packet Trace Interface (PTI) Initialization</h3>
<p>Packet trace on the EFR32 provides a mechanism for viewing transmitted and received radio packets for network sniffing or debugging. It can also be captured by a WSTK and sent to Simplicity Studio for viewing the data in its Network Analyzer tool.</p>
<p>If you want to use this functionality, you must configure what pins you want to use for this output and, optionally how you want to format the data. Note that the WSTK requires the following output format: </p>
<pre class="fragment">Mode: 8 bit UART mode
Baudrate: 1.6Mbps
Framing Signal: Enabled
</pre><p>If you change anything here it is currently unsupported by the WSTK. In the future we may include support for alternate output modes.</p>
<p>To choose the pins you want you must look in the data sheet for your part and select a valid route location for the FRC_DOUT and FRC_DFRAME signals. These map to PTI.DATA and PTI.FRAME on the WSTK respectively. Once you've found pins that work for your hardware you need to configure the RouteLocation, port, and pin fields in the PTI initialization structure. When using the WSTK for example, you should initialize things as follows.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;pti.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> initPti(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  RADIO_PTIInit_t ptiInit =   {</div>
<div class="line">    RADIO_PTI_MODE_UART,    <span class="comment">// Only supported output mode for the WSTK</span></div>
<div class="line">    1600000,                <span class="comment">// Choose 1.6 Mbps for the WSTK</span></div>
<div class="line">    6,                      <span class="comment">// WSTK uses location 6 for DOUT</span></div>
<div class="line">    gpioPortB,              <span class="comment">// FRC_DOUT#6 is PB12</span></div>
<div class="line">    12,                     <span class="comment">// FRC_DOUT#6 is PB12</span></div>
<div class="line">    6,                      <span class="comment">// UNUSED IN UART MODE</span></div>
<div class="line">    gpioPortB,              <span class="comment">// UNUSED IN UART MODE</span></div>
<div class="line">    11,                     <span class="comment">// UNUSED IN UART MODE</span></div>
<div class="line">    6,                      <span class="comment">// WSTK uses location 6 for DFRAME</span></div>
<div class="line">    gpioPortB,              <span class="comment">// FRC_DOUT#6 is PB13</span></div>
<div class="line">    13,                     <span class="comment">// FRC_DOUT#6 is PB13</span></div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Initialize the Packet Trace Interface (PTI)</span></div>
<div class="line">  RADIO_PTI_Init(&amp;ptiInit);</div>
<div class="line">}</div>
</div><!-- fragment --><h3>Other Radio GPIO Functions</h3>
<p>There are various useful signals related to the radio that can be output on a GPIO using the Peripheral Reflex System (PRS). The PRS is an advanced system where you can route signals to channels and then output those channels to a number of configurable locations. There's a lot more to it than that, so consult the reference manual chapter on the PRS if you want to understand it better.</p>
<p>A list of some of the most interesting PRS signals related to the radio is shown below along with how to enable them in the PRS.</p>
<table class="doxtable">
<tr>
<th align="left">Signal </th><th align="left">Summary </th><th align="left">PRS Source (efr32xg1) </th><th align="left">PRS Source (efr32xg12) </th><th align="left">PRS Signal  </th></tr>
<tr>
<td align="left">RACACTIVE </td><td align="left">Radio enabled </td><td align="left">0x20 </td><td align="left">0x51 </td><td align="left">0x00 </td></tr>
<tr>
<td align="left">RACTX </td><td align="left">Transmit mode enabled </td><td align="left">0x20 </td><td align="left">0x51 </td><td align="left">0x01 </td></tr>
<tr>
<td align="left">RACRX </td><td align="left">Receive mode enabled </td><td align="left">0x20 </td><td align="left">0x51 </td><td align="left">0x02 </td></tr>
<tr>
<td align="left">RACLNAEN </td><td align="left">LNA enabled for Rx </td><td align="left">0x20 </td><td align="left">0x51 </td><td align="left">0x03 </td></tr>
<tr>
<td align="left">RACPAEN </td><td align="left">PA enabled for Tx </td><td align="left">0x20 </td><td align="left">0x51 </td><td align="left">0x04 </td></tr>
<tr>
<td align="left">MODEM_FRAMEDET </td><td align="left">Frame detected </td><td align="left">0x26 </td><td align="left">0x56 </td><td align="left">0x00 </td></tr>
<tr>
<td align="left">MODEM_PREDET </td><td align="left">Preamble detected </td><td align="left">0x26 </td><td align="left">0x56 </td><td align="left">0x01 </td></tr>
<tr>
<td align="left">MODEM_TIMDET </td><td align="left">Timing detected </td><td align="left">0x26 </td><td align="left">0x56 </td><td align="left">0x02 </td></tr>
<tr>
<td align="left">MODEM_FRAMESENT </td><td align="left">Frame sent </td><td align="left">0x26 </td><td align="left">0x56 </td><td align="left">0x03 </td></tr>
<tr>
<td align="left">MODEM_SYNCSENT </td><td align="left">Syncword sent </td><td align="left">0x26 </td><td align="left">0x56 </td><td align="left">0x04 </td></tr>
<tr>
<td align="left">MODEM_PRESENT </td><td align="left">Preamble sent </td><td align="left">0x26 </td><td align="left">0x56 </td><td align="left">0x05 </td></tr>
</table>
<p>The example below shows you how to configure a PRS channel to output RACRX on a GPIO. For this example we assume you're using the SLWSTK6001A_EFR32MG kit. The specified configuration will put RACRX on PRS Channel 0 and output PRS Channel 0 on the EFR32's PC10 which is wired to WSTK_P12 and EXP_HEADER15 on the WSTK.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;em_cmu.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;em_gpio.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;em_device.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> enableDebugGpios(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Turn on the PRS and GPIO clocks so we can access their registers</span></div>
<div class="line">  CMU_ClockEnable(cmuClock_PRS, <span class="keyword">true</span>);</div>
<div class="line">  CMU_ClockEnable(cmuClock_GPIO, <span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Configure PC10 as an output</span></div>
<div class="line">  GPIO_PinModeSet(gpioPortC, 10, gpioModePushPull, 0);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Configure PRS Channel 0 to output RACRX</span></div>
<div class="line">  PRS-&gt;CH[0].CTRL = (0x20 &lt;&lt; _PRS_CH_CTRL_SOURCESEL_SHIFT)</div>
<div class="line">                     | (0x02 &lt;&lt; _PRS_CH_CTRL_SIGSEL_SHIFT)</div>
<div class="line">                     | PRS_CH_CTRL_EDSEL_OFF;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Configure PRS Channel 0 to use output location 12 (PC10 - see datasheet)</span></div>
<div class="line">  PRS-&gt;ROUTELOC0 &amp;= ~_PRS_ROUTELOC0_CH0LOC_MASK;</div>
<div class="line">  PRS-&gt;ROUTELOC0 |= PRS_ROUTELOC0_CH0LOC_LOC12;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Enable PRS Channel 0</span></div>
<div class="line">  PRS-&gt;ROUTEPEN |= PRS_ROUTEPEN_CH0PEN;</div>
<div class="line">}</div>
</div><!-- fragment --><h2>Required Dependencies</h2>
<p>Most of the RAIL library is self contained, however, there are some dependencies on external functions. Specifically, we rely on functions from the C standard library, EMLIB, and CMSIS. Below is a complete list of these dependencies. If you want to change the implementation of any of these functions while maintaining the functionality that's fine, just know that they could impact RAIL operation.</p>
<table class="doxtable">
<tr>
<th>Group </th><th>Functions  </th></tr>
<tr>
<td>CMSIS </td><td><code>SystemHFXOClockGet()</code><br/>
<code>SystemLFRCOClockGet()</code><br/>
<code>SystemLFXOClockGet()</code><br/>
<code>SystemULFRCOClockGet()</code> </td></tr>
<tr>
<td>EMLIB (em_cmu) </td><td><code>CMU_ClockFreqGet()</code><br/>
<code>CMU_ClockEnable()</code><br/>
<code>CMU_ClockSelectSet()</code><br/>
<code>CMU_OscillatorEnable()</code> </td></tr>
<tr>
<td>EMLIB (em_gpio) </td><td><code>GPIO_PinModeSet()</code> </td></tr>
<tr>
<td>EMLIB (em_system) </td><td><code>SYSTEM_ChipRevisionGet()</code> </td></tr>
<tr>
<td>EMLIB (em_core) </td><td><code>CORE_EnterCritical()</code><br/>
<code>CORE_ExitCritical()</code> </td></tr>
<tr>
<td>stdlib </td><td><code>memcpy()</code><br/>
<code>memset()</code> </td></tr>
</table>
<h2>Peripherals Consumed by RAIL</h2>
<p>Currently, RAIL consumes only peripherals that are a part of the radio.</p>
<h3>Future Peripheral Considerations</h3>
<p>In the future, RAIL might use a few of the customer facing peripherals for enhanced functionality. In preparation, below is a list of potential peripherals that could be shared in future RAIL releases.</p>
<ul>
<li>PRS Channels</li>
<li>RTCC Timer</li>
</ul>
<h2>Entropy Generation</h2>
<p>The EFR32 supports true entropy collection using the radio. It is able to collect 1 bit per radio clock cycle while in receive mode. This means that we must enable the receiver when collecting entropy and if you attempt to transmit or otherwise delay entry into receive it will take us a longer time to collect the data. You can still receive packets while collecting entropy and this does mean that requesting random numbers longer than the length of your preamble and sync word may trigger a packet reception. This may be fixed in a future revision but for now this is done to ensure proper packet reception during random data collection.</p>
<p>Due to the nature of random data collection we will always wait for the full amount requested so we should return either the number of bytes requested or zero. Zero is returned if the radio is uninitialized and cannot be enabled for collection.</p>
<h2>Radio Calibration</h2>
<p>The EFR32 supports two radio calibration options: image rejection (IR) calibration and VCO temperature calibration. You may choose to enable one or both of these based upon your specific situation. We always recommend using both, but here is more information.</p>
<ul>
<li>Image Rejection Calibration (IRCAL)<ul>
<li>This calibration should be run once every time your PHY config changes. It is based on the modulation scheme, frequency band, and other radio settings. RAIL will request this via the <a class="el" href="group___calibration.html#ga0bba03efcc5f21c29b74775f6f257361" title="Callback that notifies the application that a calibration is needed. ">RAILCb_CalNeeded()</a> callback with the <a class="el" href="group___e_f_r32.html#ga97381526c792e093e656130c9a11f12d">RAIL_CAL_ONETIME_IRCAL</a> bit set in <a class="el" href="group___calibration.html#ga92c97ac0bc23db396309fa56c40bb8ae" title="Returns the current set of pending calibrations. ">RAIL_CalPendingGet()</a>.</li>
<li>Using a proper value for this will improve sensitivity by several dBm, so it's highly recommended.</li>
<li>It can take on the order of 700 ms to complete this calibration. You may want to save off a known good value for this calibration and load it each time you switch PHYs to save time.</li>
<li>This calibration should be initialized before channel configuration in order to provide parameters specific to the current radio config. The initialization parameters come from Simplicity Studio's application builder.</li>
<li>You cannot use the radio while this calibration is being performed or you may generate an incorrect calibration. Application code should ensure that the radio remains in the idle state during this calibration.</li>
<li>This calibration should be performed only after the radio config has been downloaded to the radio, calibration initialization has occurred, and the frequency channel has been configured.</li>
</ul>
</li>
<li>VCO Temperature Calibration (VCO_TEMPCAL)<ul>
<li>If you sit in receive for a very long time and experience temperature swings it's possible for the radio to drift off frequency. When this situation is detected RAIL will request this calibration via the <a class="el" href="group___calibration.html#ga0bba03efcc5f21c29b74775f6f257361" title="Callback that notifies the application that a calibration is needed. ">RAILCb_CalNeeded()</a> callback with the <a class="el" href="group___e_f_r32.html#ga28feea6fbfddfe14e4ba5290b301081d">RAIL_CAL_TEMP_VCO</a> bit set in <a class="el" href="group___calibration.html#ga92c97ac0bc23db396309fa56c40bb8ae" title="Returns the current set of pending calibrations. ">RAIL_CalPendingGet()</a>.</li>
<li>This calibration is automatically run every time we enter receive. So if you are frequently forcing a re-enter into receive mode you may not need to enable this calibration.</li>
<li>On EFR, the application will get a RAIL_CalNeeded() callback for VCO calibration when the absolute temperature crosses 0C degrees as well as when the temperature delta from the last calibration increases or decreases by 70C.</li>
<li>We always recommend that you enable and handle this calibration since it doesn't add much overhead and is much safer if you ever do end up in this situation. </li>
</ul>
</li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Apr 7 2017 16:17:14 for RAIL by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
