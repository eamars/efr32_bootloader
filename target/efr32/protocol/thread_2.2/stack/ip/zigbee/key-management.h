/*
 * File: key-management.h
 * Description: key management for ZigBee-IP
 *
 * Copyright 2012 by Ember Corporation. All rights reserved.                *80*
 */

// This has to handle both Thread keys and legacy keys.  Both derive
// MAC and MLE keys from a single master key using a SHA256-HMAC hash.
// We have to support Thread only and Thread+legacy stacks.  The 
// additional legacy code is protected by "#ifdef EMBER_WAKEUP_STACK".
//
// In legacy systems a network has a master key and associated
// one-byte key sequence number.  The MAC and MLE keys depend only on
// the master key.  Legacy networks never switch to a new master key.
// There was a mechanism for doing so, but it was never used.
//
// In Thread the sequence number is 32 bits and the MAC and MLE keys
// are generated by a hash that uses both the master key and the key
// sequence number.  Switching to a new key is done by incrementing
// the sequence number and generating new MAC and MLE keys.  A device
// that has the master key can generate the keys for any sequence number
// value.
//
// Thread has a mechanism for distributing a new master key.
// Switching to a new master key invalidates all keys derived from the
// old one.  Hybrid Thread/legacy networks are not allowed to change
// the master key.

//----------------------------------------------------------------
// These are only used in legacy tokens.

enum KeyState_e {
  KEY_UNINITIALIZED = 0,        // so that we start up uninitialized
  KEY_NEXT,
  KEY_OLD_IN_USE,
  KEY_IN_USE
};

#define LEGACY_KEY_SEQUENCE_NUMBER 1

// The Thread spec has two parameters for key sequence changes:
//  - thrKeyRotation: how often you increment the key sequence number.
//    This is in the commission dataset.
//    The default is 672 hours, must be at least one hour, maximum
//    is 2**32.
//  - thrKeySwitchGuardTime: don't accept key sequence change unless
//    at least this amount of time has passed, default is 624 hours.
//    This is not in the commission dataset, which is a problem with
//    the spec, because this needs to change if thrKeyRotation does.
// When forming or joining a network the guard time is assumed to have
// already passed.
//
// Event queues run into wraparound issues with delays of around 600 hours
// (delay is 32 bits, 2**31 msec is just over 596 hours).  So we need to
// have an extra counter.

#define DEFAULT_THREAD_KEY_ROTATION_HOURS 672
#define DEFAULT_THREAD_KEY_GUARD_HOURS    624
#define MS_PER_HOUR       		          (60 * 60 * 1000)

// The derived keys are the MLE key followed by the MAC key.  The order is
// determined by their order in the master key hash result.

#define MLE_KEY_OFFSET      0
#define MAC_KEY_OFFSET      EMBER_ENCRYPTION_KEY_SIZE

// In the MAC AUX frame Thread uses 1-128 to encode the low seven bits
// of the actual key sequence number.  This gives us a window of
//  [activeKeySequence - 64, activeKeySequence + 63]
// For each neighbor and child we are synchronized with we store
//    theirActiveKeySequence - ourActiveKeySequence
// as an int8_u whose value is in [-64, 63].

void emClearNetworkKeys(void);
void emRestoreKeys(void);
void emResetKeys(void);
void emFormSecurityInit(void);
void emJoinSecurityInit(void);

const uint8_t *emGetNetworkMasterKey(uint8_t *storage);
void emSetNetworkMasterKey(uint8_t const *key, uint32_t sequence);

uint8_t *emDeriveMleAndMacKeys(uint32_t sequence, uint8_t *keyBuffer);
void emSetNetworkKeySequence(uint32_t sequence);
void emEnableKeySwitching(uint32_t sequence);
void emScheduleKeyRotation(void);
bool emIsActiveKeySequence(uint32_t keySequence);
bool emIsPriorKeySequence(uint32_t keySequence);
const uint8_t *emGetActiveMacKeyAndSequence(uint32_t *sequenceNumberLoc);
void emNoteMacKeyUse(uint32_t keySequence);
  
// When using an 8-bit MAC sequence number field Thread sends the
// low seven bits of the 32-bit key sequence number, plus one.  The
// one is added because 802.15.4 does not allow the sequence number
// field to be zero.  The over-the-air values used are 1-128.  The
// 129-255 values are currently reserved.

#define emShrinkSequenceNumber(sequence) ((sequence & 0x7F) + 1)
bool emIsShortActiveKeySequence(uint8_t shortKeySequence);
uint32_t emExpandSequenceNumber(uint8_t shortKeySequence);

bool emSetKeySequenceDelta(uint32_t keySequence,
                           int8_t *sequenceDeltaLoc);

/*
bool emSequenceNumberIsNewer(uint32_t sequenceNumber);
bool emDeriveKey(uint32_t sequence,
                 uint8_t *derivedKey,
                 uint8_t *legacyKey);
*/
