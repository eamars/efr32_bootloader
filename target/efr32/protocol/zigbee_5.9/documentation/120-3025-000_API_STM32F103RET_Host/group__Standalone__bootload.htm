<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>EmberZNet API Reference: For the STM32F103RET Host platform</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
</head>
<body>
<div id="top"><!-- do not remove this div! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td><img src="SiliconLabsLogo_Black.jpg" style="padding: 10px;width:40%;height:40%;" /></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">EmberZNet API Reference: For the STM32F103RET Host platform
   &#160;<span id="projectnumber">EmberZNet 5.9.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.8.2 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__Standalone__bootload.htm','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Stand-Alone Bootloader Library</div>  </div>
<div class="ingroups"><a class="el" href="group__util__bootload.htm">Bootloading</a></div></div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga0bb58ffff72970f64cc3e038b19e55fe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Standalone__bootload.htm#ga0bb58ffff72970f64cc3e038b19e55fe">BOOTLOAD_HARDWARE_TAG_SIZE</a></td></tr>
<tr class="separator:ga0bb58ffff72970f64cc3e038b19e55fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gad6359d2c7ec802211ed9b35965583b7d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Standalone__bootload.htm#gad6359d2c7ec802211ed9b35965583b7d">bootloadMode</a> { <br/>
&#160;&#160;<a class="el" href="group__Standalone__bootload.htm#ggad6359d2c7ec802211ed9b35965583b7dae5c39d92a264d0b7853c0c27d5eb6193">BOOTLOAD_MODE_NONE</a>, 
<br/>
&#160;&#160;<a class="el" href="group__Standalone__bootload.htm#ggad6359d2c7ec802211ed9b35965583b7daf09b78c45ad5588fa745b2445496b179">BOOTLOAD_MODE_PASSTHRU</a>
<br/>
 }</td></tr>
<tr class="separator:gad6359d2c7ec802211ed9b35965583b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d9aa56e997feecd0af723b0e0832c96"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Standalone__bootload.htm#ga0d9aa56e997feecd0af723b0e0832c96">bootloadState</a> { <br/>
&#160;&#160;<a class="el" href="group__Standalone__bootload.htm#gga0d9aa56e997feecd0af723b0e0832c96af2dd3c800bcf081e86b4376341344ab0">BOOTLOAD_STATE_NORMAL</a>, 
<br/>
&#160;&#160;<a class="el" href="group__Standalone__bootload.htm#gga0d9aa56e997feecd0af723b0e0832c96a25aa09b089d337bbae7fd448785057b0">BOOTLOAD_STATE_QUERY</a>, 
<br/>
&#160;&#160;<a class="el" href="group__Standalone__bootload.htm#gga0d9aa56e997feecd0af723b0e0832c96acec20473acb40368cf005b1507590f3a">BOOTLOAD_STATE_WAIT_FOR_AUTH_CHALLENGE</a>, 
<br/>
&#160;&#160;<a class="el" href="group__Standalone__bootload.htm#gga0d9aa56e997feecd0af723b0e0832c96a3d2c65568b5ce979cfcc86a7c365f0f5">BOOTLOAD_STATE_WAIT_FOR_AUTH_RESPONSE</a>, 
<br/>
&#160;&#160;<a class="el" href="group__Standalone__bootload.htm#gga0d9aa56e997feecd0af723b0e0832c96a12ce4fb4c2d187c75a6008c03ed4734d">BOOTLOAD_STATE_DELAY_BEFORE_START</a>, 
<br/>
&#160;&#160;<a class="el" href="group__Standalone__bootload.htm#gga0d9aa56e997feecd0af723b0e0832c96acc3fda1b3b6b1a8154bef1c045df6443">BOOTLOAD_STATE_START_UNICAST_BOOTLOAD</a>, 
<br/>
&#160;&#160;<a class="el" href="group__Standalone__bootload.htm#gga0d9aa56e997feecd0af723b0e0832c96aae9727414f3dd62774fd13c0c93a9d14">BOOTLOAD_STATE_START_BROADCAST_BOOTLOAD</a>, 
<br/>
&#160;&#160;<a class="el" href="group__Standalone__bootload.htm#gga0d9aa56e997feecd0af723b0e0832c96a671d63c7a4d1cc2757358a8a2efd4723">BOOTLOAD_STATE_START_SENDING_IMAGE</a>, 
<br/>
&#160;&#160;<a class="el" href="group__Standalone__bootload.htm#gga0d9aa56e997feecd0af723b0e0832c96a2096b6bc01f079370487e9f89f0db2f5">BOOTLOAD_STATE_SENDING_IMAGE</a>, 
<br/>
&#160;&#160;<a class="el" href="group__Standalone__bootload.htm#gga0d9aa56e997feecd0af723b0e0832c96a0b725f41d59728e0e0ac21459fdc97f9">BOOTLOAD_STATE_WAIT_FOR_IMAGE_ACK</a>, 
<br/>
&#160;&#160;<a class="el" href="group__Standalone__bootload.htm#gga0d9aa56e997feecd0af723b0e0832c96abaa749d4f8f29e11c7816905baaeb494">BOOTLOAD_STATE_WAIT_FOR_COMPLETE_ACK</a>, 
<br/>
&#160;&#160;<a class="el" href="group__Standalone__bootload.htm#gga0d9aa56e997feecd0af723b0e0832c96a9c95543122488c0cedc265b92e5f2615">BOOTLOAD_STATE_DONE</a>
<br/>
 }</td></tr>
<tr class="separator:ga0d9aa56e997feecd0af723b0e0832c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga076c2b87c3e65b544e5e4f939036541a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Standalone__bootload.htm#ga076c2b87c3e65b544e5e4f939036541a">bootloadUtilInit</a> (uint8_t appPort, uint8_t bootloadPort)</td></tr>
<tr class="separator:ga076c2b87c3e65b544e5e4f939036541a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fcc45db8bb80beb5c597660e5a4549f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ember__types.htm#gacff561a945530f3039d6715958418ab8">EmberStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Standalone__bootload.htm#ga6fcc45db8bb80beb5c597660e5a4549f">bootloadUtilSendRequest</a> (<a class="el" href="group__ember__types.htm#ga21de0cf5f8f6730bc3be6c7ec2b82050">EmberEUI64</a> targetEui, uint16_t mfgId, uint8_t hardwareTag[<a class="el" href="group__Standalone__bootload.htm#ga0bb58ffff72970f64cc3e038b19e55fe">BOOTLOAD_HARDWARE_TAG_SIZE</a>], uint8_t encryptKey[<a class="el" href="group__Standalone__bootload.htm#ga46259b91722dd8b23503726d0ff84782">BOOTLOAD_AUTH_COMMON_SIZE</a>], <a class="el" href="group__Standalone__bootload.htm#gad6359d2c7ec802211ed9b35965583b7d">bootloadMode</a> mode)</td></tr>
<tr class="separator:ga6fcc45db8bb80beb5c597660e5a4549f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga209915103771a4c19dc17b5697fefa49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Standalone__bootload.htm#ga209915103771a4c19dc17b5697fefa49">bootloadUtilSendQuery</a> (<a class="el" href="group__ember__types.htm#ga21de0cf5f8f6730bc3be6c7ec2b82050">EmberEUI64</a> target)</td></tr>
<tr class="separator:ga209915103771a4c19dc17b5697fefa49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga308447b903fb3113a016da273c000425"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Standalone__bootload.htm#ga308447b903fb3113a016da273c000425">bootloadUtilStartBootload</a> (<a class="el" href="group__ember__types.htm#ga21de0cf5f8f6730bc3be6c7ec2b82050">EmberEUI64</a> target, <a class="el" href="group__Standalone__bootload.htm#gad6359d2c7ec802211ed9b35965583b7d">bootloadMode</a> mode)</td></tr>
<tr class="separator:ga308447b903fb3113a016da273c000425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97082ca0b6380dc00afbe3b30bf6ba95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Standalone__bootload.htm#ga97082ca0b6380dc00afbe3b30bf6ba95">bootloadUtilTick</a> (void)</td></tr>
<tr class="separator:ga97082ca0b6380dc00afbe3b30bf6ba95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e7cc0e7b5932b756f704445d2b2a19d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Standalone__bootload.htm#ga1e7cc0e7b5932b756f704445d2b2a19d">bootloadUtilLaunchRequestHandler</a> (uint16_t manufacturerId, uint8_t hardwareTag[<a class="el" href="group__Standalone__bootload.htm#ga0bb58ffff72970f64cc3e038b19e55fe">BOOTLOAD_HARDWARE_TAG_SIZE</a>], <a class="el" href="group__ember__types.htm#ga21de0cf5f8f6730bc3be6c7ec2b82050">EmberEUI64</a> sourceEui)</td></tr>
<tr class="separator:ga1e7cc0e7b5932b756f704445d2b2a19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46c0dd0079bd71be8ae5469422c86084"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Standalone__bootload.htm#ga46c0dd0079bd71be8ae5469422c86084">bootloadUtilQueryResponseHandler</a> (bool bootloaderActive, uint16_t manufacturerId, uint8_t hardwareTag[<a class="el" href="group__Standalone__bootload.htm#ga0bb58ffff72970f64cc3e038b19e55fe">BOOTLOAD_HARDWARE_TAG_SIZE</a>], <a class="el" href="group__ember__types.htm#ga21de0cf5f8f6730bc3be6c7ec2b82050">EmberEUI64</a> targetEui, uint8_t bootloaderCapabilities, uint8_t platform, uint8_t micro, uint8_t phy, uint16_t blVersion)</td></tr>
<tr class="separator:ga46c0dd0079bd71be8ae5469422c86084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga006e68f885620a9df038ab8e411f27a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Standalone__bootload.htm#ga006e68f885620a9df038ab8e411f27a1">bootloadUtilSendAuthResponse</a> (<a class="el" href="group__ember__types.htm#ga21de0cf5f8f6730bc3be6c7ec2b82050">EmberEUI64</a> target)</td></tr>
<tr class="separator:ga006e68f885620a9df038ab8e411f27a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Authentication Challenge and Response</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp9bdf60ee3fe3c22683cb97ba450db6a6"></a> The authentication challenge and response must be the same size. The size is chosen to be evenly divisible by the size of a 128-bit AES block. </p>
</td></tr>
<tr class="memitem:ga46259b91722dd8b23503726d0ff84782"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Standalone__bootload.htm#ga46259b91722dd8b23503726d0ff84782">BOOTLOAD_AUTH_COMMON_SIZE</a></td></tr>
<tr class="separator:ga46259b91722dd8b23503726d0ff84782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebacffaaffed77f0b40af1e12a11aa55"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Standalone__bootload.htm#gaebacffaaffed77f0b40af1e12a11aa55">BOOTLOAD_AUTH_CHALLENGE_SIZE</a></td></tr>
<tr class="separator:gaebacffaaffed77f0b40af1e12a11aa55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab279f692e45da4bd210a09564121ddae"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Standalone__bootload.htm#gab279f692e45da4bd210a09564121ddae">BOOTLOAD_AUTH_RESPONSE_SIZE</a></td></tr>
<tr class="separator:gab279f692e45da4bd210a09564121ddae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Bootload State Variables</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp7f646a0eccad346a4f9071c4dee0fca0"></a> Used to check whether a bootloading process is currently happening. </p>
</td></tr>
<tr class="memitem:ga2d4f8874078cfed8e420392237e14cbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Standalone__bootload.htm#ga0d9aa56e997feecd0af723b0e0832c96">bootloadState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Standalone__bootload.htm#ga2d4f8874078cfed8e420392237e14cbe">blState</a></td></tr>
<tr class="separator:ga2d4f8874078cfed8e420392237e14cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga379208e17c0584e6672f6d6ec3c71d50"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Standalone__bootload.htm#ga379208e17c0584e6672f6d6ec3c71d50">IS_BOOTLOADING</a></td></tr>
<tr class="separator:ga379208e17c0584e6672f6d6ec3c71d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>All functions and variables defined here can be used by applications. See <a class="el" href="bootload-utils_8h.htm" title="Utilities used for performing stand-alone bootloading. See Bootloading for documentation.">bootload-utils.h</a> for source code.</p>
<p>Applications can use this stand-alone bootload library to:</p>
<ol type="1">
<li>Load a new (application) image on itself via serial bootload through uart port 1 using the xmodem protocol.</li>
<li>Load a new image on a remote node over-the-air (OTA) from a host (PC), also known as a passthru bootload.</li>
<li>Recover a node that failed during the bootloading process, also known as a recovery bootload.</li>
</ol>
<p>Note from the diagrams below that with over-the-air bootloading the source node (node transmitting bootload packets) and the target node (node being loaded with a new image) need to be one hop away because bootload packets are IEEE 802.15.4 packets.</p>
<p>In case of recovery, the source (recovery) node does not need to be part of the network since all recovery packets are 802.15.4 packets.</p>
<p><b>A diagram for typical serial bootloading:</b></p>
<p>[host pc] &ndash;(RS232 or Ethernet/IP network)&ndash; {uart1 or port 4901}[node]</p>
<p><b>A diagram for typical passthru bootloading:</b></p>
<p>[host pc] &ndash;(RS232 or Ethernet)&ndash; [source node]&ndash;(OTA)&ndash;[target node]</p>
<p><b>A diagram for typical recovery bootloading:</b></p>
<p>[source node] &ndash;(OTA)&ndash;[target node]</p>
<dl class="section note"><dt>Note</dt><dd>Applications that use the bootload utilities need to <code> #define EMBER_APPLICATION_HAS_BOOTLOAD_HANDLERS </code> within their <code> CONFIGURATION_HEADER </code>. </dd></dl>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga46259b91722dd8b23503726d0ff84782"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BOOTLOAD_AUTH_COMMON_SIZE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="bootload-utils_8h_source.htm#l00066">66</a> of file <a class="el" href="bootload-utils_8h_source.htm">bootload-utils.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaebacffaaffed77f0b40af1e12a11aa55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BOOTLOAD_AUTH_CHALLENGE_SIZE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="bootload-utils_8h_source.htm#l00067">67</a> of file <a class="el" href="bootload-utils_8h_source.htm">bootload-utils.h</a>.</p>

</div>
</div>
<a class="anchor" id="gab279f692e45da4bd210a09564121ddae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BOOTLOAD_AUTH_RESPONSE_SIZE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="bootload-utils_8h_source.htm#l00068">68</a> of file <a class="el" href="bootload-utils_8h_source.htm">bootload-utils.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga0bb58ffff72970f64cc3e038b19e55fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BOOTLOAD_HARDWARE_TAG_SIZE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of hardware tag which is an array of uint8_t. </p>
<p>// End set of defines </p>

<p>Definition at line <a class="el" href="bootload-utils_8h_source.htm#l00076">76</a> of file <a class="el" href="bootload-utils_8h_source.htm">bootload-utils.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga379208e17c0584e6672f6d6ec3c71d50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IS_BOOTLOADING</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="bootload-utils_8h_source.htm#l00300">300</a> of file <a class="el" href="bootload-utils_8h_source.htm">bootload-utils.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gad6359d2c7ec802211ed9b35965583b7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Standalone__bootload.htm#gad6359d2c7ec802211ed9b35965583b7d">bootloadMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bootload modes supported by the bootload utility library. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggad6359d2c7ec802211ed9b35965583b7dae5c39d92a264d0b7853c0c27d5eb6193"></a>BOOTLOAD_MODE_NONE</em>&nbsp;</td><td>
<p>Used when we are not currently doing any bootloading. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad6359d2c7ec802211ed9b35965583b7daf09b78c45ad5588fa745b2445496b179"></a>BOOTLOAD_MODE_PASSTHRU</em>&nbsp;</td><td>
<p>Used when doing normal and recovery passthru bootload. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="bootload-utils_8h_source.htm#l00082">82</a> of file <a class="el" href="bootload-utils_8h_source.htm">bootload-utils.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga0d9aa56e997feecd0af723b0e0832c96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Standalone__bootload.htm#ga0d9aa56e997feecd0af723b0e0832c96">bootloadState</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A bootload state is a value that an application can check to see if bootloading is in progress. </p>
<p>This is necessary because we want the application to be aware that bootloading is going on and it needs to limit its activities. For example, when passthru bootloading is going on, do not print anything to a serial port because it may violate the XModem protocol. Also, try to limit radio activities to a minimum to avoid any interruptions to bootload progress. Used in a bootload state machine. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga0d9aa56e997feecd0af723b0e0832c96af2dd3c800bcf081e86b4376341344ab0"></a>BOOTLOAD_STATE_NORMAL</em>&nbsp;</td><td>
<p>Start state </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga0d9aa56e997feecd0af723b0e0832c96a25aa09b089d337bbae7fd448785057b0"></a>BOOTLOAD_STATE_QUERY</em>&nbsp;</td><td>
<p>After send query message </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga0d9aa56e997feecd0af723b0e0832c96acec20473acb40368cf005b1507590f3a"></a>BOOTLOAD_STATE_WAIT_FOR_AUTH_CHALLENGE</em>&nbsp;</td><td>
<p>Wait for authentication challenge </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga0d9aa56e997feecd0af723b0e0832c96a3d2c65568b5ce979cfcc86a7c365f0f5"></a>BOOTLOAD_STATE_WAIT_FOR_AUTH_RESPONSE</em>&nbsp;</td><td>
<p>Wait for authentication response </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga0d9aa56e997feecd0af723b0e0832c96a12ce4fb4c2d187c75a6008c03ed4734d"></a>BOOTLOAD_STATE_DELAY_BEFORE_START</em>&nbsp;</td><td>
<p>Delay state before start new action </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga0d9aa56e997feecd0af723b0e0832c96acc3fda1b3b6b1a8154bef1c045df6443"></a>BOOTLOAD_STATE_START_UNICAST_BOOTLOAD</em>&nbsp;</td><td>
<p>After start unicast bootloading </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga0d9aa56e997feecd0af723b0e0832c96aae9727414f3dd62774fd13c0c93a9d14"></a>BOOTLOAD_STATE_START_BROADCAST_BOOTLOAD</em>&nbsp;</td><td>
<p>After start broadcast bootloading </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga0d9aa56e997feecd0af723b0e0832c96a671d63c7a4d1cc2757358a8a2efd4723"></a>BOOTLOAD_STATE_START_SENDING_IMAGE</em>&nbsp;</td><td>
<p>Need to start XMODEM code </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga0d9aa56e997feecd0af723b0e0832c96a2096b6bc01f079370487e9f89f0db2f5"></a>BOOTLOAD_STATE_SENDING_IMAGE</em>&nbsp;</td><td>
<p>During sending OTA data messages </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga0d9aa56e997feecd0af723b0e0832c96a0b725f41d59728e0e0ac21459fdc97f9"></a>BOOTLOAD_STATE_WAIT_FOR_IMAGE_ACK</em>&nbsp;</td><td>
<p>Wait for OTA data ack </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga0d9aa56e997feecd0af723b0e0832c96abaa749d4f8f29e11c7816905baaeb494"></a>BOOTLOAD_STATE_WAIT_FOR_COMPLETE_ACK</em>&nbsp;</td><td>
<p>Wait for OTA end transmission ack </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga0d9aa56e997feecd0af723b0e0832c96a9c95543122488c0cedc265b92e5f2615"></a>BOOTLOAD_STATE_DONE</em>&nbsp;</td><td>
<p>Finish bootloading </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="bootload-utils_8h_source.htm#l00106">106</a> of file <a class="el" href="bootload-utils_8h_source.htm">bootload-utils.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga076c2b87c3e65b544e5e4f939036541a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bootloadUtilInit </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>appPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bootloadPort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bootload library initialization. </p>
<p>The application needs to define the ports to be used for printing information and for a (passthru) bootload.</p>
<dl class="section note"><dt>Note</dt><dd>Generally it's a good idea to use different ports for the application and for bootloading because when doing passthru bootloading, we do not want to print any additional data that can cause an XModem transaction to fail.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">appPort</td><td>Port used for printing information. </td></tr>
    <tr><td class="paramname">bootloadPort</td><td>Port used for passthru bootloading. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6fcc45db8bb80beb5c597660e5a4549f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ember__types.htm#gacff561a945530f3039d6715958418ab8">EmberStatus</a> bootloadUtilSendRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ember__types.htm#ga21de0cf5f8f6730bc3be6c7ec2b82050">EmberEUI64</a>&#160;</td>
          <td class="paramname"><em>targetEui</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>mfgId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>hardwareTag</em>[BOOTLOAD_HARDWARE_TAG_SIZE], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>encryptKey</em>[BOOTLOAD_AUTH_COMMON_SIZE], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Standalone__bootload.htm#gad6359d2c7ec802211ed9b35965583b7d">bootloadMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the bootload process on a remote node that is currently running stack/application. </p>
<p>The source node sends a bootload request message to initiate the bootload authentication process. The source node then enters a state waiting for the target node to send an authentication challenge, which it will encrypt and send back as a response. MfgId and harwareTag information is sent over the air to the target node to verify whether to go into bootload mode. The encryption key is saved on the source node for later authentication. The mode indicates the bootload mode that the source will be using.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">targetEui</td><td>Node to be bootloaded. </td></tr>
    <tr><td class="paramname">mfgId</td><td>Manufacturer ID (vendor specific). </td></tr>
    <tr><td class="paramname">hardwareTag</td><td>Hardware ID, such as a board (vendor specific). </td></tr>
    <tr><td class="paramname">encryptKey</td><td>Key used in the authentication process. </td></tr>
    <tr><td class="paramname">mode</td><td>Bootload mode to be used is passthru (0x01). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EMBER_SUCESS if successful, or EMBER_NO_BUFFERS, or EMBER_ERR_FATAL if the function was called too soon after a previous call to it. </dd></dl>

</div>
</div>
<a class="anchor" id="ga209915103771a4c19dc17b5697fefa49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bootloadUtilSendQuery </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ember__types.htm#ga21de0cf5f8f6730bc3be6c7ec2b82050">EmberEUI64</a>&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to send query message to gather basic information about the node(s). </p>
<p>There are two types of query messages: broadcast and unicast. Broadcast query is generally used to gather information regarding a neighboring node, especially the eui64 of the node. Unicast query is used when we already know the eui64 of the target node that we needs information from.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The node we want to gather information from. If the value is NULL, that means we want to do a broadcast query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga308447b903fb3113a016da273c000425"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bootloadUtilStartBootload </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ember__types.htm#ga21de0cf5f8f6730bc3be6c7ec2b82050">EmberEUI64</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Standalone__bootload.htm#gad6359d2c7ec802211ed9b35965583b7d">bootloadMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the bootload process on a remote node that is already running in bootload mode. </p>
<p>This is generally to recover a node that failed during bootload. The failure can be caused by the source node resetting, the network being too busy, a software reset, and so on. However, the failure is not caused by a target node losing power. After the failure, the node stays in bootload mode on the same (current) channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>remote node to be bootloaded. If the value is NULL, that means we do not know the eui64 of the target node. A broadcast (start bootload) packet is sent and the first node that replies will be bootloaded. </td></tr>
    <tr><td class="paramname">mode</td><td>bootload mode to be used, such as passthru (0x01). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga97082ca0b6380dc00afbe3b30bf6ba95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bootloadUtilTick </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function in the application's heartbeat or tick function that contains basic bootloading state machine and also manages the bootload timer. </p>

</div>
</div>
<a class="anchor" id="ga1e7cc0e7b5932b756f704445d2b2a19d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bootloadUtilLaunchRequestHandler </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>manufacturerId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>hardwareTag</em>[BOOTLOAD_HARDWARE_TAG_SIZE], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ember__types.htm#ga21de0cf5f8f6730bc3be6c7ec2b82050">EmberEUI64</a>&#160;</td>
          <td class="paramname"><em>sourceEui</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A callback function invoked by bootload-utils when a bootload request message is received. </p>
<p>The application may choose whether or not to enter the bootloader by checking the manufacturerId, hardwareTag, and sourceEui. If the application chooses to launch the bootloader, the bootloader will launch after successful completion of the bootloader launch authentication protocol.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">manufacturerId</td><td>The manufacturer specification (vendor specific) of the sending node. </td></tr>
    <tr><td class="paramname">hardwareTag</td><td>The hardware specification (vendor specific) of the sending node. </td></tr>
    <tr><td class="paramname">sourceEui</td><td>The EUI64 of the sending node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the application wishes to launch the bootloader, false if the application does not wish to launch the bootloader. </dd></dl>

</div>
</div>
<a class="anchor" id="ga46c0dd0079bd71be8ae5469422c86084"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bootloadUtilQueryResponseHandler </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bootloaderActive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>manufacturerId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>hardwareTag</em>[BOOTLOAD_HARDWARE_TAG_SIZE], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ember__types.htm#ga21de0cf5f8f6730bc3be6c7ec2b82050">EmberEUI64</a>&#160;</td>
          <td class="paramname"><em>targetEui</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bootloaderCapabilities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>platform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>micro</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>phy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>blVersion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A callback function invoked by bootload-utils when a bootload query response message is received. </p>
<p>This is particularly useful when the application needs to decide which node to bootload. Several attributes of the responding node are provided to the application. The application can use these attributes to decide whether to bootload or how to bootload a given node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bootloaderActive</td><td>true if the responding node is running the bootloader, false if not. </td></tr>
    <tr><td class="paramname">manufacturerId</td><td>The manufacturer specification (vendor specific) of the responding node. </td></tr>
    <tr><td class="paramname">hardwareTag</td><td>The hardware specification (vendor specific) of the responding node. </td></tr>
    <tr><td class="paramname">targetEui</td><td>The EUI64 of the responding node. </td></tr>
    <tr><td class="paramname">bootloaderCapabilities</td><td>If the lsb is 1, the bootloader on the responding node supports encrypted bootloader message payloads. </td></tr>
    <tr><td class="paramname">platform</td><td>The type of platform of the responding node. 1 is avr-atmega, 2 is xap2b. </td></tr>
    <tr><td class="paramname">micro</td><td>The type of microcontroller on the responding node. Value depends on platform. 1 is the avr-atmega 64, 2 is the avr-atmega 128, 1 is the xap2b em250. </td></tr>
    <tr><td class="paramname">phy</td><td>The type of phy of the responding node. 1 is em2420, 2 is em250. </td></tr>
    <tr><td class="paramname">blVersion</td><td>The version of standalone bootloader of the responding node. This is a 2 byte field. The high byte is the version and the low byte is the build. A value of 0xFFFF means unknown. For example, a version field of 0x1234 is version 1.2, build 34. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga006e68f885620a9df038ab8e411f27a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bootloadUtilSendAuthResponse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ember__types.htm#ga21de0cf5f8f6730bc3be6c7ec2b82050">EmberEUI64</a>&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function called by a parent node to send an authentication response message to the sleepy or mobile end-device target node. </p>
<p>The message is sent as a Just-In-Time (JIT) message, hence, the end-device target needs to poll for the message.</p>
<p>The bootload utility library will call this function automatically if bootloading the router node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The end-device target node being bootloaded. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga2d4f8874078cfed8e420392237e14cbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Standalone__bootload.htm#ga0d9aa56e997feecd0af723b0e0832c96">bootloadState</a> blState</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<hr size="1">
<table border="0" cellspacing="0" cellpadding="0" width=100%>
<tr>
<td><address><small>
EmberZNet API Reference: For the STM32F103RET Host platform. EmberZNet 5.9.2.0.
</small></address>
</td>
<td align="right">
<address><small>
</small></address>
</td>
</tr>
</table>
</body>
</html>
